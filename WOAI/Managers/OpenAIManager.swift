//
//  OpenAIManager.swift
//  WOAI
//
//  Created by ÏñëÏäπÏôÑ on 11/27/24.
//

import Foundation

protocol OpenAiManagerProtocol {
    func appendMeetingMembers(members:[String])
    func sendMessageStream(text: String) async throws -> AsyncThrowingStream<MeetingTaskDTO, Error>
}

class OpenAiManager: @unchecked Sendable, OpenAiManagerProtocol {
  
    private var systemMessage: Message
    private let temperature: Double
    private let model: String

    private let apiKey: String
    private var historyList = [Message]()
    private let urlSession = URLSession.shared
    private var urlRequest: URLRequest {
        let url = URL(string: "https://api.openai.com/v1/chat/completions")!
        var urlRequest = URLRequest(url: url)
        urlRequest.httpMethod = "POST"
        headers.forEach { urlRequest.setValue($1, forHTTPHeaderField: $0) }
        return urlRequest
    }

    private let jsonDecoder: JSONDecoder = {
        let jsonDecoder = JSONDecoder()
        jsonDecoder.keyDecodingStrategy = .convertFromSnakeCase
        return jsonDecoder
    }()

    private var headers: [String: String] {
        [
            "Content-Type": "application/json",
            "Authorization": "Bearer \(apiKey)"
        ]
    }


    init(apiKey: String, model: String = "gpt-4o", temperature: Double = 0.5) {
        self.apiKey = apiKey
        self.model = model

        let systemPrompt = """
     ÎãπÏã†ÏùÄ ÌöåÏùò ÎåÄÌôîÎ•º Î∂ÑÏÑùÌïòÏó¨ Íµ¨Ï°∞ÌôîÎêú JSONÏúºÎ°ú Ï†ïÎ¶¨ÌïòÎäî Í≥†Í∏â ÎπÑÏÑú AIÏûÖÎãàÎã§.

     Ï£ºÏñ¥ÏßÑ ÌöåÏùò ÌÖçÏä§Ìä∏Î•º Í∏∞Î∞òÏúºÎ°ú Îã§ÏùåÏùò JSON Íµ¨Ï°∞Ïóê ÎßûÏ∂∞ ÎÇ¥Ïö©ÏùÑ ÏöîÏïΩ Î∞è Î∂ÑÎ•òÌïòÏÑ∏Ïöî:

     ---

     üßæ **ÏµúÏÉÅÏúÑ Ìï≠Î™© (ÌöåÏùò Î©îÌÉÄ Ï†ïÎ≥¥)**

     - `MeetingTitle`: ÌöåÏùòÏùò Ï£ºÏ†ú ÎòêÎäî Ï†úÎ™©ÏùÑ ÏöîÏïΩ
     - `MeetingSummary`: ÌöåÏùòÏùò Ï£ºÏöî ÎÇ¥Ïö©ÏùÑ Îëê Î¨∏Ïû• Ïù¥ÎÇ¥Î°ú ÏöîÏïΩ
     - `RecordedAt`: ÌöåÏùòÍ∞Ä Ïó¥Î¶∞ ÎÇ†Ïßú Î∞è ÏãúÍ∞Ñ (Ïòà: "2025-04-25 Ïò§Ï†Ñ 10Ïãú")

     ---

     üìå **Issues (ÌöåÏùò Ï§ë ÎÖºÏùòÎêú Ïù¥Ïäà)**

     - Í∞Å Ïù¥ÏäàÎäî Îã§Ïùå ÌïÑÎìúÎ•º Ìè¨Ìï®Ìï©ÎãàÎã§:
       - `IssueName`: ÎÖºÏùòÎêú Ï£ºÏ†ú ÎòêÎäî Î¨∏Ï†úÏùò Ïù¥Î¶Ñ
       - `Details`: Ïñ¥Îñ§ ÎÇ¥Ïö©ÏùÑ ÎÖºÏùòÌñàÎäîÏßÄ ÏÉÅÏÑ∏Ìûà ÏÑ§Î™Ö
       - `ActionItems`: ÌõÑÏÜçÏúºÎ°ú ÏàòÌñâÌï¥Ïïº Ìï† ÏûëÏóÖ Î¶¨Ïä§Ìä∏ (Î¨∏ÏûêÏó¥ Î∞∞Ïó¥)

     ---

     üïí **Timeline (ÏãúÍ∞Ñ ÌùêÎ¶Ñ ÏöîÏïΩ)**

     - ÌöåÏùò Ï§ë Í∞Å ÏãúÍ∞ÑÎåÄÏóê Ïñ¥Îñ§ Ï£ºÏ†úÎ•º Îã§Î§òÎäîÏßÄ Í∏∞Î°ùÌï©ÎãàÎã§:
       - `Time`: "Ïò§Ï†Ñ 10Ïãú", "Ïò§ÌõÑ 3Ïãú" Îì±Ïùò ÌòïÏãù
       - `Discussion`: Ìï¥Îãπ ÏãúÍ∞ÑÏóê Ïù¥Î£®Ïñ¥ÏßÑ Ï£ºÏöî ÎÖºÏùò

     ---

     üìÖ **SchedulingTasks (ÏïΩÏÜç Î∞è ÏùºÏ†ï)**

     - ÌöåÏùò Ï§ë Ïñ∏Í∏âÎêú Îã§Ïùå ÏùºÏ†ïÏù¥ÎÇò ÌöåÏùò Îì±ÏùÑ Ï†ïÎ¶¨Ìï©ÎãàÎã§:
       - `Subject`: ÌöåÏùòÎÇò ÏïΩÏÜçÏùò Ï†úÎ™©
       - `Date`: ÏïΩÏÜç ÎÇ†Ïßú (Ïòà: "Îã§Ïùå Ï£º ÏõîÏöîÏùº")
       - `Time`: ÏïΩÏÜç ÏãúÍ∞Ñ
       - `Participants`: Ï∞∏Ïó¨Ïûê Î¶¨Ïä§Ìä∏

     ---

     üí° Ï£ºÏùò:

     - `MeetingTitle`, `MeetingSummary`, `RecordedAt`Îäî **Issues Î∞ñÏóê ÏúÑÏπò**
     - `RecordedAt`ÏùÄ ÌöåÏùò Ï†ÑÏ≤¥Ïùò ÏãúÏ†êÏùÑ ÎÇòÌÉÄÎÇ¥Î©∞, Í∞Å Ïù¥ÏäàÏóêÎäî Ìè¨Ìï®ÎêòÏßÄ ÏïäÏùå
     - Í∞ÄÎä•Ìïú Ìïú Íµ¨Ï≤¥Ï†ÅÏù¥Í≥† Í∞ÑÍ≤∞Ìïú ÌëúÌòÑÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî

     ---

     Ïù¥Ï†ú Îã§Ïùå ÌöåÏùò ÎåÄÌôî ÎÇ¥Ïö©ÏùÑ Í∏∞Î∞òÏúºÎ°ú ÏúÑÏôÄ Í∞ôÏùÄ Íµ¨Ï°∞Î°ú JSONÏùÑ ÏÉùÏÑ±Ìï¥ Ï£ºÏÑ∏Ïöî.

    {
      "MeetingTitle": "WOAI Ïò®Î≥¥Îî© Í∏∞Îä• ÌöåÏùò",
      "MeetingSummary": "ÌòÑÏû¨ Ïä§ÌîÑÎ¶∞Ìä∏ ÏÉÅÌô©ÏùÑ Ï†êÍ≤ÄÌïòÍ≥† Ïã†Í∑ú Ïò®Î≥¥Îî© Í∏∞Îä•ÏùÑ Î∏åÎ†àÏù∏Ïä§ÌÜ†Î∞çÌï®.",
      "RecordedAt": "2025-04-25 Ïò§Ï†Ñ 10Ïãú",
      "Issues": [
        {
          "IssueName": "ÌîÑÎ°úÏ†ùÌä∏ ÏóÖÎç∞Ïù¥Ìä∏",
          "Details": "ÌòÑÏû¨ Ïä§ÌîÑÎ¶∞Ìä∏ ÏßÑÌñâ ÏÉÅÌô©ÏùÑ ÎÖºÏùòÌïòÍ≥†, Ïû•Ïï† ÏöîÏù∏ÏùÑ ÌôïÏù∏ÌñàÏúºÎ©∞, Ìï¥Í≤∞ Î∞©ÏïàÏùÑ Ï†úÏïàÌï®.",
          "ActionItems": [
            "Ïû•Ïï† ÏöîÏù∏ AÎ•º Í∏àÏöîÏùºÍπåÏßÄ Ìï¥Í≤∞",
            "ÎßàÏºÄÌåÖ ÌåÄÍ≥º ÏΩòÌÖêÏ∏† ÏäπÏù∏ Í¥ÄÎ†® ÌõÑÏÜç Ï°∞Ïπò."
          ]
        },
        {
          "IssueName": "Í∏∞Îä• Î∏åÎ†àÏù∏Ïä§ÌÜ†Î∞ç",
          "Details": "Ïã†Í∑ú Ïò®Î≥¥Îî© Í∏∞Îä•Ïóê ÎåÄÌïú ÏïÑÏù¥ÎîîÏñ¥Î•º Î∏åÎ†àÏù∏Ïä§ÌÜ†Î∞çÌïòÍ≥†, Ï†úÏïàÏùò Ïã§ÌòÑ Í∞ÄÎä•ÏÑ±ÏùÑ ÌèâÍ∞ÄÌï®.",
          "ActionItems": [
            "Ï†úÏïàÎêú Í∏∞Îä• BÏùò Ï¥àÍ∏∞ ÏÑ§Í≥Ñ ÏûëÏÑ±",
            "Îã§Ïùå ÌöåÏùò Ï†Ñ Ïã§ÌòÑ Í∞ÄÎä•ÏÑ± Î≥¥Í≥† Ï§ÄÎπÑ."
          ]
        }
      ],
      "Timeline": [
        {
          "Time": "Ïò§Ï†Ñ 10Ïãú",
          "Discussion": "ÌîÑÎ°úÏ†ùÌä∏ ÏóÖÎç∞Ïù¥Ìä∏Î•º Í≤ÄÌÜ†ÌïòÍ≥† Ïû•Ïï† ÏöîÏù∏Ïóê ÎåÄÌï¥ ÎÖºÏùòÌï®."
        },
        {
          "Time": "Ïò§Ï†Ñ 10Ïãú 30Î∂Ñ",
          "Discussion": "Ïã†Í∑ú Ïò®Î≥¥Îî© Í∏∞Îä•Ïóê ÎåÄÌïú ÏïÑÏù¥ÎîîÏñ¥Î•º Î∏åÎ†àÏù∏Ïä§ÌÜ†Î∞çÌï®."
        }
      ],
      "SchedulingTasks": [
        {
          "Subject": "ÌåÄ ÎØ∏ÌåÖ",
          "Date": "Îã§Ïùå Ï£º ÏõîÏöîÏùº",
          "Time": "Ïò§ÌõÑ 3Ïãú",
          "Participants": ["John", "Emma", "Alex"]
        }
      ]
    }

   

"""

        self.systemMessage = .init(role: "system", content: systemPrompt)
        self.temperature = temperature
    }

    // Metodo per ottenere il systemMessage
    func getSystemMessage() -> Message {
        return systemMessage
    }

    private func generateMessages(from text: String) -> [Message] {
        var messages = [systemMessage] + historyList
        messages.append(Message(role: "user", content: text))

        // Limita la cronologia per evitare di superare il limite di token
        let maxCharacterLimit = 3000000 // Imposta un limite di caratteri
        var totalCharacters = messages.contentCount
        while totalCharacters > maxCharacterLimit {
            if historyList.count > 2 {
                historyList.removeFirst()
                messages = [systemMessage] + historyList + [messages.last!]
                totalCharacters = messages.contentCount
            } else {
                
                if let lastMessage = messages.last {
                    let allowedContentCount = maxCharacterLimit - messages.dropLast().contentCount
                    if allowedContentCount > 0 {
                        let truncatedContent = String(lastMessage.content.prefix(allowedContentCount))
                        messages[messages.count - 1] = Message(role: lastMessage.role, content: truncatedContent)
                    } else {
                        messages.removeLast()
                    }
                    break
                }
            }
        }

        return messages
    }

    private func jsonBody(text: String, stream: Bool = true) throws -> Data {
        let request = Request(model: model, temperature: temperature,
                              messages: generateMessages(from: text), stream: stream)
        print(request)
        return try JSONEncoder().encode(request)
        
    }

    private func appendToHistoryList(systemText: String, responseText: String) {
        self.historyList.append(.init(role: "system", content: systemText))
    }
    
 

    // Funzione per inviare messaggi in streaming
    func sendMessageStream(text: String) async throws -> AsyncThrowingStream<MeetingTaskDTO, Error> {
        var urlRequest = self.urlRequest
        urlRequest.httpBody = try jsonBody(text: text)

        let (result, response) = try await urlSession.bytes(for: urlRequest)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw NSError.customError(withMessage: "Invalid response")
        }

        guard 200...299 ~= httpResponse.statusCode else {
            print("error \(httpResponse.statusCode)")
            var errorText = ""
            for try await line in result.lines {
                errorText += line
            }

            if let data = errorText.data(using: .utf8), let errorResponse = try? jsonDecoder.decode(ErrorRootResponse.self, from: data).error {
                errorText = "\n\(errorResponse.message)"
            }

            throw NSError.customError(withMessage: "Bad Response: \(httpResponse.statusCode), \(errorText)")
        }

        return AsyncThrowingStream<MeetingTaskDTO, Error> { continuation in
            Task(priority: .userInitiated) { [weak self] in
                guard let self = self else { return }
                do {
                    var responseText = ""
                    for try await line in result.lines {
                        if line.hasPrefix("data: "),
                            let data = line.dropFirst(6).data(using: .utf8),
                            let response = try? self.jsonDecoder.decode(StreamCompletionResponse.self, from: data),
                            let text = response.choices.first?.delta.content {
                            responseText += text
                        }
                    }
                    
                    do {
                        let stripped = stripMarkdownCodeBlock(from: responseText)
                        print("stripped **\(stripped)**")
                        let task = try await JsonManager.shared.getJson(stripped)
                        continuation.yield(task)
                    } catch {
                        print("stripped, JSON ERROR")
                        continuation.finish(throwing: error)
                    }

                    self.appendToHistoryList(systemText: text, responseText: responseText)
                    continuation.finish()
                } catch {
                    continuation.finish(throwing: error)
                }
            }
        }
    }
  
}

extension OpenAiManager {
    func appendMeetingMembers(members: [String]) {
        let content = self.systemMessage.content + "ÎåÄÌôîÏóê Ï∞∏Ïó¨ÏûêÎäî \(members.reduce(""){ $0+","+$1 }) Ïù¥Ïïº ~Îãò Ïù¥ÎùºÍ≥† ÌåêÎ≥ÑÎêúÍ±∞ Í∞ôÏùÄ Í≤ΩÏö∞Ïóê ÎπÑÏä∑Ìïú Ïù¥Î¶ÑÏù¥ ÏûàÏúºÎ©¥ Î∞îÍøîÏ§ò \n ex) ÍµêÌòïÎãò -> Í∑úÏòÅÎãò"
        self.systemMessage = Message(role: self.systemMessage.role, content: content)
    }
    func stripMarkdownCodeBlock(from text: String) -> String {
        var cleaned = text

        // Îß® ÏïûÏóê ```json ÎòêÎäî ``` Ï†úÍ±∞
        cleaned = cleaned.replacingOccurrences(of: #"(?m)^```json\s*\n"#, with: "", options: .regularExpression)
        cleaned = cleaned.replacingOccurrences(of: #"(?m)^```\s*\n"#, with: "", options: .regularExpression)

        // Îß® Îí§Ïóê ``` Ï†úÍ±∞
        cleaned = cleaned.replacingOccurrences(of: #"(?m)^```\s*$"#, with: "", options: .regularExpression)

        return cleaned
    }
}

// Estensione per creare errori personalizzati
extension NSError {
    static func customError(withMessage message: String) -> NSError {
        return NSError(domain: "", code: 1, userInfo: [NSLocalizedDescriptionKey: message])
    }
}
